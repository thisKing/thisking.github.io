{"meta":{"title":"边个懂","subtitle":"","description":"","author":"边个懂","url":"https://webbgd.cn","root":"/"},"pages":[{"title":"关于","date":"2021-02-28T08:22:03.865Z","updated":"2021-02-28T08:22:03.865Z","comments":false,"path":"about/index.html","permalink":"https://webbgd.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-02-28T08:02:16.134Z","updated":"2021-02-28T08:02:16.134Z","comments":true,"path":"links/index.html","permalink":"https://webbgd.cn/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-01T14:09:07.841Z","updated":"2021-02-28T08:22:22.181Z","comments":false,"path":"tags/index.html","permalink":"https://webbgd.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-28T08:22:16.414Z","updated":"2021-02-28T08:22:16.414Z","comments":false,"path":"categories/index.html","permalink":"https://webbgd.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"移动端自适应 (一)","slug":"数据结构-链表","date":"2021-03-11T15:51:00.000Z","updated":"2021-03-11T15:54:35.114Z","comments":true,"path":"2021/03/11/数据结构-链表/","link":"","permalink":"https://webbgd.cn/2021/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"基本概念一、基本概念 CSS像素、设备像素、逻辑像素、设备像素比 viewport rem 二、工作原理 利用 viewport 和设备像素比调整基准像素 利用px2rem自动转换css单位 CSS像素、设备像素、逻辑像素、设备像素比CSS像素、逻辑像素 === CSS px像素单位设备像素：设备机器手机上的物理像素（不同版手机不一样）设备像素比：CSS像素和设备(物理)像素的比值：1px像素有2个设备(物理)像素点，1比2。dpr viewport12345678&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;width: 控制 viewport 的大小，可指定值，如：device-width 为设备的宽度（单位为缩放100%时的CSS的像素）。height：width相对于，指定高度。initial-scale：初始缩放比例，第一次加载的时候1缩放比例。maximum-scale: 用户最大缩放。minimum-scale：用户最小比例。user-scalable：是否可以手动缩放。 rem 和 em 像素单位 rem // 相对 html 标签的 font-size 单位 em // 相对父级 font-size 单位 例子 12345678&lt;html stlye=&quot;font-size: 100px&quot;&gt; &lt;p style=&quot;font-size: 1rem; height: 1rem&quot;&gt;内容&lt;/p&gt;&lt;/html&gt;// 此时的 p 字体 100px 像素，高度 100px 像素// 变化 html 中的 font-size 就能影响改变所有 rem 值 设计稿–苹果5CSS像素 320设备相似比dpr = 2设备像素 320 * 2 = 640 // 设计稿应该是640？ hotcss复制下边代码保存，引用即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117(function(window, document) &#123; // 给hotcss开辟个命名空间，别问我为什么，我要给你准备你会用到的方法，免得用到的时候还要自己写。 const hotcss = &#123;&#125;;(function() &#123; // 根据devicePixelRatio自定计算scale // 可以有效解决移动端1px这个世纪难题。 let viewportEl = document.querySelector(&quot;meta[name=\\&quot;viewport\\&quot;]&quot;), hotcssEl = document.querySelector(&quot;meta[name=\\&quot;hotcss\\&quot;]&quot;), dpr = window.devicePixelRatio || 1, maxWidth = 540, designWidth = 0 dpr = dpr &gt;= 3 ? 3 : (dpr &gt;= 2 ? 2 : 1) // 允许通过自定义name为hotcss的meta头，通过initial-dpr来强制定义页面缩放 if (hotcssEl) &#123; const hotcssCon = hotcssEl.getAttribute(&quot;content&quot;);if (hotcssCon) &#123; const initialDprMatch = hotcssCon.match(/initial\\-dpr=([\\d\\.]+)/) if (initialDprMatch) &#123; dpr = parseFloat(initialDprMatch[1]) &#125; const maxWidthMatch = hotcssCon.match(/max\\-width=([\\d\\.]+)/) if (maxWidthMatch) &#123; maxWidth = parseFloat(maxWidthMatch[1]) &#125; const designWidthMatch = hotcssCon.match(/design\\-width=([\\d\\.]+)/) if (designWidthMatch) &#123; designWidth = parseFloat(designWidthMatch[1]) &#125; &#125; &#125; document.documentElement.setAttribute(&quot;data-dpr&quot;, dpr) hotcss.dpr = dpr document.documentElement.setAttribute(&quot;max-width&quot;, maxWidth) hotcss.maxWidth = maxWidth if (designWidth) &#123; document.documentElement.setAttribute(&quot;design-width&quot;, designWidth) &#125; hotcss.designWidth = designWidth // 保证px2rem 和 rem2px 不传第二个参数时, 获取hotcss.designWidth是undefined导致的NaN let scale = 1 / dpr, content = `width=device-width, initial-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, user-scalable=no`;if (viewportEl) &#123; viewportEl.setAttribute(&quot;content&quot;, content) &#125; else &#123; viewportEl = document.createElement(&quot;meta&quot;) ;viewportEl.setAttribute(&quot;name&quot;, &quot;viewport&quot;) ;viewportEl.setAttribute(&quot;content&quot;, content) document.head.appendChild(viewportEl) &#125; &#125;)() hotcss.px2rem = function(px, designWidth) &#123; // 预判你将会在JS中用到尺寸，特提供一个方法助你在JS中将px转为rem。就是这么贴心。 if (!designWidth) &#123; // 如果你在JS中大量用到此方法，建议直接定义 hotcss.designWidth 来定义设计图尺寸; // 否则可以在第二个参数告诉我你的设计图是多大。 designWidth = parseInt(hotcss.designWidth, 10) &#125; return parseInt(px, 10) * 320 / designWidth / 20 &#125; hotcss.rem2px = function(rem, designWidth) &#123; // 新增一个rem2px的方法。用法和px2rem一致。 if (!designWidth) &#123; designWidth = parseInt(hotcss.designWidth, 10) &#125; // rem可能为小数，这里不再做处理了 return rem * 20 * designWidth / 320 &#125; hotcss.mresize = function() &#123; // 对，这个就是核心方法了，给HTML设置font-size。 let innerWidth = document.documentElement.getBoundingClientRect().width || window.innerWidth if (hotcss.maxWidth &amp;&amp; (innerWidth / hotcss.dpr &gt; hotcss.maxWidth)) &#123; innerWidth = hotcss.maxWidth * hotcss.dpr &#125; if (!innerWidth) &#123; return false &#125; document.documentElement.style.fontSize = `$&#123;innerWidth * 20 / 320&#125;px` ;hotcss.callback &amp;&amp; hotcss.callback() &#125; hotcss.mresize() // 直接调用一次 window.addEventListener(&quot;resize&quot;, () =&gt; &#123; clearTimeout(hotcss.tid) ;hotcss.tid = setTimeout(hotcss.mresize, 33) &#125;, false) // 绑定resize的时候调用 window.addEventListener(&quot;load&quot;, hotcss.mresize, false) // 防止不明原因的bug。load之后再调用一次。 setTimeout(() =&gt; &#123; hotcss.mresize() // 防止某些机型怪异现象，异步再调用一次 &#125;, 333) window.hotcss = hotcss // 命名空间暴露给你，控制权交给你，想怎么调怎么调。&#125;)(window, document)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://webbgd.cn/categories/CSS/"}],"tags":[{"name":"概念","slug":"概念","permalink":"https://webbgd.cn/tags/%E6%A6%82%E5%BF%B5/"},{"name":"CSS","slug":"CSS","permalink":"https://webbgd.cn/tags/CSS/"},{"name":"移动端","slug":"移动端","permalink":"https://webbgd.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"边个懂"},{"title":"数据结构-集合","slug":"数据结构-集合","date":"2021-03-11T15:50:00.000Z","updated":"2021-03-11T15:51:21.981Z","comments":true,"path":"2021/03/11/数据结构-集合/","link":"","permalink":"https://webbgd.cn/2021/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/","excerpt":"","text":"概念 一种无序且唯一的数据结构ES6中有集合，名为 Set JS 中 Set 操作 Set 对象 new let mySet = new Set() add mySet.add(1); mySet.add(2); mySet.add(&#123;a:1,b:2&#125;); // 存储内存地址所以有多个看起来一样的 mySet.add(&#123;a:1,b:2&#125;); // 存储内存地址所以有多个看起来一样的 delete mySet.delete(1); has mySet.has(2); size mySet.size(); // 3 迭代 Set 迭代方法 for ( let item of mySet || mySet.keys() || mySet.values() || mySet.entries()) console.log(item) Set与Array互转 const arr1 = [...mySet] const arr2 = Array.from(mySet) mySet2 = new Set([1,2,3,4]) 集合的常用操作 去重 判断某元素是否在集合中 求交集 代码例子去重12const arr = [1,1,2,2,3]const arr2 = [...new Set(arr)] 判断元素是否在集合中12const set = new Set([1,1,2,2,3])const has = set.has(1) 求交集1234const set1 = new Set([1,1,2,2,3])const set2 = new Set([2,3])const set3 = new Set([...set1].filter(item =&gt; set2.has(item))) 力扣算法题两个数组的交集（349题号）给定两个数组，编写一个函数计算它们的交集。 输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：2 1234567891011// 步骤1、用集合对 nums1 去重// 步骤2、遍历 nums1，筛选 nums2 也包含的值let intersection = function(nums1, nums2) &#123; return [...new Set(nums1)].filter(item =&gt; nums2.includes(item));&#125;时间复杂度 O(n2)空间复杂度 O(m)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://webbgd.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://webbgd.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"边个懂"},{"title":"简单使用 mockjs","slug":"简单使用 mockjs","date":"2021-03-02T16:14:33.000Z","updated":"2021-03-03T11:39:44.845Z","comments":true,"path":"2021/03/03/简单使用 mockjs/","link":"","permalink":"https://webbgd.cn/2021/03/03/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%20mockjs/","excerpt":"","text":"下载 npm install mockjs mock 文件 创建一个文件夹比如：mock (我是放在根目录下) 在该文件夹下创建 index.js（mock主文件，引入user.js等其它文件） 创建user.js文件（主要放user接口返回内容） index.js 代码12345678910111213141516171819202122// 引入mockjsimport Mock from &#x27;mockjs&#x27;// 引入user接口文件import user from &#x27;./user&#x27;// 引入多个的时候，用于展开平铺引入的接口const mocks = [ ...user]// 遍历每个接口注册到 mock 中mocks.forEach(e =&gt; &#123; Mock.mock( new RegExp(e.url), e.type || &#x27;get&#x27;, e.response )&#125;);// 引入导出 mockexport default Mock user.js 代码1234567891011121314151617181920212223// Mock 里面有很多模拟接口返回随机数据import Mock from &#x27;mockjs&#x27;// 返回数组（多个接口）export default [ &#123; url: &#x27;/user&#x27;, // 接口地址 type: &#x27;get&#x27;, // 接口类型（get,post） response: () =&gt; &#123; // 响应体 const data = Mock.mock(&#123; name: &#x27;@cname&#x27;, sInspectSee: &#x27;@cparagraph()&#x27;, iPrintPureImg: &#x27;@boolean(1, 5, true)&#x27; &#125;) return &#123; msg: &#x27;成功-mock&#x27;, data: data, &#125; &#125; &#125;] mockjs官网–模拟随机数据语法 vue 全局引入在 main.js 主文件中引入 123// 通过判断不等于生产环境（用户使用的环境）下引入。（相对绝对都行只要引入到上边创建的mock文件下的 index.js 即可）if (process.env.NODE_ENV !== &#x27;production&#x27;) require(&#x27;../mock&#x27;) 组件中接口调用12345678910111213// 引入 promise 实现版“ajax”网络请求import axios from &#x27;axios&#x27;export default &#123; mounted() &#123; // 请求： 地址是 user.js 创建的 /user 路径 axios.get(&#x27;/user&#x27;).then( res =&gt; &#123; // 返回结果 &#123; msg: &quot;成功-mock&quot;, data: &#123;...&#125;&#125; 。成功对上user.js中写的 response 响应值 console.log(res.data) &#125;) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://webbgd.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://webbgd.cn/tags/JavaScript/"},{"name":"npm","slug":"npm","permalink":"https://webbgd.cn/tags/npm/"},{"name":"Vue","slug":"Vue","permalink":"https://webbgd.cn/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://webbgd.cn/tags/Webpack/"}],"author":"边个懂"},{"title":"简单使用 axios","slug":"简单使用 axios","date":"2021-03-02T16:13:57.000Z","updated":"2021-03-03T11:40:22.447Z","comments":true,"path":"2021/03/03/简单使用 axios/","link":"","permalink":"https://webbgd.cn/2021/03/03/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%20axios/","excerpt":"","text":"下载 npm install axios vue 全局引入在 main.js 主文件中引入 import axios from ‘axios’Vue.prototype.$http = axios // 放入到vue原型中（全局引入） 组件中接口调用1234567891011// 引入 promise 实现版“ajax”网络请求export default &#123; mounted() &#123; // 上一步已经引入到vue（this）中 this.$http.get(&#x27;/user&#x27;).then( res =&gt; &#123; console.log(res.data) &#125;) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://webbgd.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://webbgd.cn/tags/JavaScript/"},{"name":"npm","slug":"npm","permalink":"https://webbgd.cn/tags/npm/"},{"name":"Vue","slug":"Vue","permalink":"https://webbgd.cn/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://webbgd.cn/tags/Webpack/"}],"author":"边个懂"},{"title":"空间&时间复杂度","slug":"空间&时间复杂度","date":"2021-03-02T15:52:11.000Z","updated":"2021-03-02T15:52:46.683Z","comments":true,"path":"2021/03/02/空间&时间复杂度/","link":"","permalink":"https://webbgd.cn/2021/03/02/%E7%A9%BA%E9%97%B4&%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度 一个函数，用大O表示，比如：O(1)、O(n)、O(LogN)定性描述该算法的运行时间 O(1)12let a = 1a += 1 a 执行了一次所以是 O(1) O(N)1234let n = 10for (let i = 0; i&lt; n; i++)&#123; //&#125; n 执行了n次所以是 O(N) O(N2)1234567let n = 10for (let i = 0; i&lt; n; i++)&#123; // for (let j = 0; j&lt; n; j++)&#123; // &#125;&#125; n 执行了 O(N) * O(N) 次所以是 O(N 2) 二次方 O(logN)1234let n = 0while (n &lt; 20)&#123; n *= 2&#125; 执行了 log n次 所以是 O(logN) 空间复杂度 一个函数，用大O表示，比如：O(1)、O(n)、O(LogN) （跟时间复杂度一样）定性描述该算法的占用的空间（内存） O(N)12345let n = 10;let list = []for (let i = 0; i&lt; n; i++)&#123; list.push(i)&#125; list 占用内存 O(N)其它空间复杂度跟时间复杂度同理….","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://webbgd.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://webbgd.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://webbgd.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"概念","slug":"概念","permalink":"https://webbgd.cn/tags/%E6%A6%82%E5%BF%B5/"}],"author":"边个懂"},{"title":"数据结构-队列","slug":"数据结构-队列","date":"2021-03-02T15:30:46.000Z","updated":"2021-03-03T11:41:22.285Z","comments":true,"path":"2021/03/02/数据结构-队列/","link":"","permalink":"https://webbgd.cn/2021/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/","excerpt":"","text":"概念 一种先进先出的数据结构 通俗概念 排队买票、排队打饭、排队打水。都是先排队的先完成。 常用的操作 js 内置函数，向数组末尾添加元素push js 内置函数，删除并返回数组的第一个元素shift 代码JavaScript 中没有队列，但是可以用 Array 实现。 12345queue = [] // 创建数组queue.push(1) // 进入queue.push(2) // 进入const item1 = queue.shift() // 出去const item2 = queue.shift() // 出去 场景食堂排队打饭计算最近请求次数JS异步中的任务队列(Event Loop)场景例子计算最近请求次数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://webbgd.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://webbgd.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"边个懂"},{"title":"数据结构-栈","slug":"数据结构-栈","date":"2021-03-02T15:12:46.000Z","updated":"2021-03-03T11:41:27.063Z","comments":true,"path":"2021/03/02/数据结构-栈/","link":"","permalink":"https://webbgd.cn/2021/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/","excerpt":"","text":"概念 一种后进先出的数据结构 通俗概念装羽毛球的羽毛球筒。把羽毛球放入到羽毛球筒中。拿出羽毛球就会从最后一个拿出。 常用的操作 js 内置函数，向数组末尾添加元素push js 内置函数，删除并返回数组的最后一个元素pop 拿数组最后一个数据stack[stack.length - 1] 代码JavaScript 中没有栈，但是可以用 Array 实现。 12345stack = [] // 创建数组stack.push(1) // 放入stack.push(2) // 放入const item1 = stack.pop() // 取出const item2 = stack.pop() // 取出 场景十进制转二进制判断字符串的括号是否有效JS函数调用过程场景例子判断字符串的括号是否有效","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://webbgd.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://webbgd.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"边个懂"},{"title":"JS 数据类型","slug":"JS数据类型","date":"2021-02-28T09:07:46.000Z","updated":"2021-03-11T15:49:55.775Z","comments":true,"path":"2021/02/28/JS数据类型/","link":"","permalink":"https://webbgd.cn/2021/02/28/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"JS数据类型 原始数据类型引用数据类型 原始数据类型 boolean null undefined number string symbol 引用数据类型 Object Array RegExp Date Math Function","categories":[{"name":"前端","slug":"前端","permalink":"https://webbgd.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://webbgd.cn/tags/JavaScript/"}],"author":"边个懂"},{"title":"this 指向问题","slug":"JS this 指向问题","date":"2021-02-28T08:56:07.000Z","updated":"2021-03-03T11:41:16.112Z","comments":true,"path":"2021/02/28/JS this 指向问题/","link":"","permalink":"https://webbgd.cn/2021/02/28/JS%20this%20%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"JavaScript 中的 this 执行规则 主要这些绑定的场景: 全局上下文 直接调用函数 对象.方法的形式调用 new构造函数绑定 箭头函数 DOM事件绑定(特殊) 全局上下文全局上下文默认this指向window, 严格模式下指向undefined。 直接调用函数123456let obj = &#123;a: function() &#123; console.log(this);&#125;&#125;let func = obj.a;func(); 这种情况是直接调用。this相当于全局上下文的情况。 对象.方法的形式调用1obj.a(); 这就是对象.方法的情况，this指向这个对象 new+构造函数此时构造函数中的this指向实例对象。 箭头函数箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。比如: 12345678let obj = &#123;a: function() &#123; let do = () =&gt; &#123; console.log(this); &#125; do();&#125;&#125;obj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj DOM事件绑定onclick和addEventerListener中 this 默认指向绑定事件的元素。IE比较奇异，使用attachEvent，里面的this默认指向window。","categories":[{"name":"前端","slug":"前端","permalink":"https://webbgd.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://webbgd.cn/tags/JavaScript/"}]}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://webbgd.cn/categories/CSS/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://webbgd.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"https://webbgd.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"概念","slug":"概念","permalink":"https://webbgd.cn/tags/%E6%A6%82%E5%BF%B5/"},{"name":"CSS","slug":"CSS","permalink":"https://webbgd.cn/tags/CSS/"},{"name":"移动端","slug":"移动端","permalink":"https://webbgd.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"https://webbgd.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://webbgd.cn/tags/JavaScript/"},{"name":"npm","slug":"npm","permalink":"https://webbgd.cn/tags/npm/"},{"name":"Vue","slug":"Vue","permalink":"https://webbgd.cn/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://webbgd.cn/tags/Webpack/"},{"name":"算法","slug":"算法","permalink":"https://webbgd.cn/tags/%E7%AE%97%E6%B3%95/"}]}